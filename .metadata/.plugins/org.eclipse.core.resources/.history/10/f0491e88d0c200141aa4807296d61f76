
public class BSTree2 
{
	private int tree[];
	private static final int INVALIDKEY = -1; 
	
	public BSTree2()
	{
		tree = new int[9999];
		
		for (int i=0; i<tree.length;i++)
		{
			tree[i] = INVALIDKEY;
		}
	}
	
	private int leftChild(int idx)
	{
		return idx*2 + 1;
	}
	
	private int rightChild(int idx)
	{
		return idx*2 + 2;
	}
	
	public void insert(int k)
	{
		// k is the key we want to insert into the array/tree
		
		int tempIdx = 0; // tempIdx will eventually be the index of the place we will insert the key k
		
		while (tree[tempIdx] != INVALIDKEY)
		{
			// change tempIdx appropriately
			if (k >= tree[tempIdx])
			{
				// move down the tree to the RIGHT
				tempIdx = rightChild(tempIdx);
			}
			else
			{
				// move down the tree to the LEFT
				tempIdx = leftChild(tempIdx);
			}
		}
		
		tree[tempIdx] = k; // that inserts k into the tree at the correct index
	}

	public void inOrderPrint()
	{
		inOrderPrint(0);
	}
	
	public void inOrderPrint(int stRootIdx)
	{
		// base case => when to stop recursing
		if (tree[stRootIdx] == INVALIDKEY)
		{
		}
		else
		{
			// 	recursive step => when to recurse
			inOrderPrint(leftChild(stRootIdx)); // lst
			System.out.println(tree[stRootIdx]);
			inOrderPrint(rightChild(stRootIdx)); // rst
		}
		
	}
}